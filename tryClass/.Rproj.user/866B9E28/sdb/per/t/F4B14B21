{
    "contents" : "\n#ifndef SAMDATA_HPP_\n#define SAMDATA_HPP_\n\nclass SamData;\n\n#include <RcppCommon.h>\n\nnamespace Rcpp {\n    template<> SEXP wrap(const SamData &s);\n    template <> SamData as( SEXP s ) ;\n}\n\n#include <Rcpp.h>\n\nclass SamData {\n\nprivate:\n\tstd::string rowname, chr1, chr2, seq1;\n\tsize_t hs1, hs2;\n\tlong id;\n\tlong start1, start2;\n\npublic:\n\n\tSamData() : hs1(0), hs2(0), id(-1), start1(0), start2(0) { }\n\tSamData(const SamData &s) { *this = s; }\n\tSamData(SamData&& o) : rowname(std::move(o.rowname)), chr1(std::move(o.chr1)), chr2(std::move(o.chr2)),\n\t\t\tseq1(std::move(o.seq1)), hs1(std::move(o.hs1)), hs2(std::move(o.hs2)), id(o.getId()),\n\t\t\tstart1(std::move(o.start1)), start2(std::move(o.start2)) { }\n\n\tSamData& operator=(const SamData& s) = default;\n\tSamData& operator=(SamData&& s) = default;\n\n\t~SamData() { }\n\n\t// getters\n\tinline long getStart1() \t\tconst { return start1; }\n\tinline long getStart2() \t\tconst { return start2; }\n\tinline std::string getSeq() \tconst { return seq1; }\n\tinline std::string getChr1()\tconst { return chr1; }\n\tinline const char* getCChr1()\tconst { return chr1.c_str(); }\n\tinline std::string getChr2()\tconst { return chr2; }\n\tinline const char* getCChr2()\tconst { return chr2.c_str(); }\n\tinline size_t getHS1() \t\t\tconst { return hs1; }\n\tinline size_t getHS2()\t \t\tconst { return hs2; }\n\tinline long getId()\t\t\t\tconst {return id; }\n\n\t// setters\n\tvoid setRowname(std::string rn) { rowname = rn; }\n\tvoid setChr1(std::string chr1_) { chr1 = chr1_; }\n\tvoid setStart1(long st) \t\t{ start1 = st; }\n\tvoid setChr2(std::string chr2_) { chr2 = chr2_; }\n\tvoid setStart2(long st) \t\t{ start2 = st; }\n\tvoid setHS1(size_t h)\t\t\t{ hs1 = h; }\n\tvoid setHS2(size_t h)\t\t\t{ hs2 = h; }\n\tvoid setId(long l)\t\t\t\t{ id = l; }\n\tvoid setSeq(std::string s)\t\t{ seq1 = s; }\n\n\t// order sam data by chr1 - should consider start1 as well\n\tinline bool operator<(const SamData &sd) const {\n\t\treturn (hs1 < sd.hs1) || (hs1 == sd.hs1 && start1 < sd.getStart1());\n\t}\n\n\t// needed to write an ordered SAM file, so that the parser does not\n\t// have to be modified. may be useful again\n\tfriend std::ostream& operator<<(std::ostream &out, const SamData &sd) {\n\t\tout << sd.rowname \t<< \"\\t\" <<\n\t\t\t\tsd.chr1 \t<< \"\\t\" <<\n\t\t\t\tsd.start1 \t<< \"\\t\" <<\n\t\t\t\tsd.chr2 \t<< \"\\t\" <<\n\t\t\t\tsd.start2 \t<< \"\\t\" <<\n\t\t\t\tsd.seq1;\n\n\t\treturn out;\n\t}\n};\n\nnamespace Rcpp {\n    \ntemplate<> SEXP wrap(const SamData &s) {\n   Rcpp::List ret = Rcpp::List::create( Rcpp::Named(\"Chr1\") = s.getChr1(),\n                              Rcpp::Named(\"Chr2\") = s.getChr2(),\n                              Rcpp::Named(\"Seq1\") = s.getSeq(),\n                              Rcpp::Named(\"HS1\")  = s.getHS1(),\n                              Rcpp::Named(\"HS2\")  = s.getHS2(),\n                              Rcpp::Named(\"Id\")   = s.getId(),\n                              Rcpp::Named(\"Start1\") = s.getStart1(),\n                              Rcpp::Named(\"Start2\") = s.getStart2() );\n    return Rcpp::wrap(ret);\n}\n\ntemplate <> SamData as( SEXP s ) {\n    Rcpp::List samL(s);\n    SamData sam;\n    sam.setChr1( Rcpp::as<std::string>(samL[\"Chr1\"]) );\n    sam.setChr2( Rcpp::as<std::string>(samL[\"Chr2\"]) );\n    sam.setSeq( Rcpp::as<std::string>(samL[\"Seq1\"]) );\n    sam.setHS1( Rcpp::as<size_t>(samL[\"HS1\"]) );\n    sam.setHS2( Rcpp::as<size_t>(samL[\"HS2\"]) );\n    sam.setStart1( Rcpp::as<long>( samL[\"Start1\"]) );\n    sam.setStart2( Rcpp::as<long>( samL[\"Start2\"]) );\n    sam.setId( Rcpp::as<long>( samL[\"Id\"]) );\n    \n    return sam;\n}\n\n}\n\n\n#endif /* SAMDATA_HPP_ */\n",
    "created" : 1432201920187.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "3169546860",
    "id" : "F4B14B21",
    "lastKnownWriteTime" : 1432247634,
    "path" : "~/RcppNC.git/trunk/tryClass/src/SamData.hpp",
    "project_path" : "src/SamData.hpp",
    "properties" : {
        "tempName" : "Untitled2"
    },
    "source_on_save" : false,
    "type" : "hpp"
}